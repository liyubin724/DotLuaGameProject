require('DotLua/Class')
require('DotLua/Timer/TimerWheel')
require('DotLua/Pool/ObjectPool')
require('DotLua/Timer/TimerTask')
require('DotLua/Timer/TimerHandler')
require('DotLua/Delegate')

local DebugLog = DebugLog

HierarchicalTimerWheel =
    Class(
    function(self)
        self.uniqueIndex = 0
        self.taskPool = ObjectPool(TimerTask)

        self.isPaused = false

        local wheel0 = self:CreateWheel(0, 100, 10)
        local wheel1 = self:CreateWheel(1, 100 * 10, 60)
        local wheel2 = self:CreateWheel(1, 100 * 10 * 60, 60)
        local wheel3 = self:CreateWheel(1, 100 * 10 * 60 * 60, 24)
        local wheel4 = self:CreateWheel(1, 100 * 10 * 60 * 60 * 24, 30)

        self.wheels = {wheel0, wheel1, wheel2, wheel3, wheel4}

        self.wheel = wheel0

        self.handlers = {}
        self.elapseInMS = 0
    end
)

function HierarchicalTimerWheel:CreateWheel(level, tick, size)
    local wheel = TimerWheel(level, tick, size)
    wheel:AddCompleteDelegate(Delegate.CreateListener(self, HierarchicalTimerWheel.OnWheelComplete))
    wheel:AddSoltTriggerDelegate(Delegate.CreateListener(self, HierarchicalTimerWheel.OnWheelSoltTrigger))
    return wheel
end

function HierarchicalTimerWheel:AddTask(intervalInSec, totalInSec, receiver, intervalFunc, endFunc, userdata)
    self.uniqueIndex = self.uniqueIndex + 1

    local task = self.taskPool:Get()
    task:SetData(self.uniqueIndex, intervalInSec, totalInSec, receiver, intervalFunc, endFunc, userdata)

    return self:InnerAddTask(task)
end

function HierarchicalTimerWheel:AddIntervalTimer(intervalInSec, receiver, intervalFunc, userdata)
    return self:AddTask(intervalInSec, 0, receiver, intervalFunc, nil, userdata)
end

function HierarchicalTimerWheel:AddEndTimer(totalInSec, receiver, endFunc, userdata)
    return self:AddTask(0, totalInSec, receiver, nil, endFunc, userdata)
end

function HierarchicalTimerWheel:RemoveTask(taskHandler)
    if taskHandler and taskHandler:IsValid() then
        self.handlers[taskHandler:GetIndex()] = nil

        local task = self.wheels[taskHandler:GetWheelIndex()]:RemoveTask(taskHandler)
        taskHandler:Clear()
        if task then
            self.taskPool:Release(task)
            return true
        end
    end

    return false
end

function HierarchicalTimerWheel:DoUpdate(deltaTime)
    if #(self.handlers) > 0 then
        self.elapseInMS = self.elapseInMS + math.ceil(deltaTime * 1000)

        if self.elapseInMS >= self.wheel:GetTickInMS() then
            local count = math.floor(self.elapseInMS / self.wheel:GetTickInMS())
            self.wheel:DoPushWheel(count)

            self.elapseInMS = math.ceil(self.elapseInMS % self.wheel:GetTickInMS())
        end
    end
end

function HierarchicalTimerWheel:Pause()
    self.isPaused = true
end

function HierarchicalTimerWheel:Resume()
    self.isPaused = false
end

function HierarchicalTimerWheel:OnWheelComplete(level)
    local nextLevel = level + 1
    if nextLevel > #(self.wheels) then
        DebugLog.Error('Timer', 'Timer error')
        return
    end

    self.wheels[nextLevel]:DoPushWheel(1)
end

function HierarchicalTimerWheel:OnWheelSoltTrigger(tasks)
    if tasks and #(tasks) > 0 then
        for _, task in pairs(tasks) do
            if task:Trigger() then
                local handler = self.handlers[task:GetIndex()]
                handler:Clear()
                self.handlers[task:GetIndex()] = nil
                self.taskPool:Release(task)
            else
                self:InnerAddTask(task)
            end
        end
    end
end

function HierarchicalTimerWheel:InnerAddTask(task)
    local handler = self.handlers[task:GetIndex()]

    local wheelIndex = -1
    local soltIndex = -1
    for i = 1, #(self.wheels) do
        local taskLeftTime = task:GetTriggerLeftInMS()
        local wheel = self.wheels[i]
        if wheel:GetTotalTickInMS() >= taskLeftTime then
            soltIndex = wheel:AddTask(task)
            wheelIndex = i
        end
    end

    if not handler then
        handler = TimerHandler(task.GetIndex(), wheelIndex, soltIndex)
    else
        handler:SetWheelIndex(wheelIndex)
        handler:SetWheelSoltIndex(soltIndex)
    end
    return handler
end

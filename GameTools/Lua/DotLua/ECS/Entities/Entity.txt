local oop = require('DotLua/OOP/oop')
local Component = require('DotLua/ECS/Components/Component')

local tlength = table.length
local tvalues = table.values
local tindexof = table.indexof
local tinsert = table.insert
local tremove = table.remove
local tclear = table.clear

local LogTag = 'Entity'

local Entity =
    oop.class(
    'Entity',
    function(self)
        self.enable = true

        self.context = nil
        self.guid = nil

        self.componentClassToInstanceDic = {}

        self.onComponentAddedEvent = oop.event()
        self.onComponentRemovedEvent = oop.event()
        self.onComponentReplacedEvent = oop.event()
        self.onComponentModifiedEvent = oop.event()
    end
)

function Entity:GetContext()
    return self.context
end

function Entity:GetGUID()
    return self.guid
end

function Entity:DoGet(context, guid)
    self.enable = true

    self.context = context
    self.guid = guid
end

function Entity:DoRelease()
    self.enable = false
end

function Entity:BindEvent(receiver, addedFunc, removedFunc, replacedFunc, modifiedFunc)
    if addedFunc then
        self.onComponentAddedEvent:Add(receiver, addedFunc)
    end

    if removedFunc then
        self.onComponentRemovedEvent:Add(receiver, removedFunc)
    end

    if replacedFunc then
        self.onComponentReplacedEvent:Add(receiver, replacedFunc)
    end

    if modifiedFunc then
        self.onComponentModifiedEvent:Add(receiver, modifiedFunc)
    end
end

function Entity:GetComponentCount()
    return tlength(self.componentClassToInstanceDic)
end

function Entity:GetAllComponents()
    return tvalues(self.componentClassToInstanceDic)
end

function Entity:HasComponentByClass(componentClass)
    if oop.isDebug then
        if not oop.isclass(componentClass) or not oop.isclassof(componentClass, Component) then
            oop.error(LogTag, 'Entity:HasComponent->the param is not a class')
            return false
        end
    end

    local component = self.componentClassToInstanceDic[componentClass]
    if not component then
        for k, _ in pairs(self.componentClassToInstanceDic) do
            if oop.iskindof(k, componentClass) then
                return true
            end
        end
        return false
    else
        return true
    end
end

function Entity:HasAllComponentsByClass(componentClasses)
    for _, componentClass in ipairs(componentClasses) do
        if not self:HasComponentByClass(componentClass) then
            return false
        end
    end

    return true
end

function Entity:HasAnyComponentByClass(componentClasses)
    for _, componentClass in ipairs(componentClasses) do
        if self:HasComponentByClass(componentClass) then
            return true
        end
    end

    return false
end

function Entity:GetComponentByClass(componentClass)
    local component = self.componentClassToInstanceDic[componentClass]
    if not component then
        for k, v in pairs(self.componentClassToInstanceDic) do
            if oop.iskindof(k, componentClass) then
                return v
            end
        end

        return nil
    else
        return component
    end
end

function Entity:AddComponentByClass(componentClass, ...)
    if not self.enable then
        oop.error(LogTag, 'The enity has been disabled')
        return nil
    end

    if oop.isDebug then
        if self:HasComponentByClass(componentClass) then
            oop.error(LogTag, string.format('The component of %s has beend added!', componentClass:GetClassName()))
            return nil
        end
    end

    local component = self.context:getComponent(componentClass, ...)
    if not component then
        oop.error(LogTag, 'the component is nil')
        return nil
    end

    self.componentClassToInstanceDic[componentClass] = component

    self.onComponentAddedEvent:Invoke(self, component)

    return component
end

function Entity:RemoveComponentByClass(componentClass,...)
    if not self.enable then
        oop.error(LogTag, 'The enity has been disabled')
        return nil
    end


end

function Entity:ReplaceComponentByClass(oldComponentClass,newComponentClass)

end

-------------------------------------------

function Entity:RemoveComponent(componentClassOrInstance)
    if not self.enable then
        oop.error('ECS', 'Entity:RemoveComponent->The enity has been disabled')
        return
    end

    self.cachedComponents = nil

    local componentClass = componentClassOrInstance
    if oop.isinstance(componentClassOrInstance) then
        componentClass = componentClassOrInstance:GetBaseClass()
    end

    local component = self:removeComponentClass(componentClass)
    self.onComponentRemovedEvent:Invoke(self, component)

    self:releaseComponent(component)
end

function Entity:removeComponentClass(componentClass)
    local key = componentClass
    local component = self.componentDic[key]
    if not component then
        for k, v in pairs(self.componentDic) do
            if oop.iskindof(k, componentClass) then
                key = k
                component = v
                break
            end
        end
    end

    if not component then
        self.componentDic[key] = nil
    end

    return component
end

function Entity:ReplaceComponent(oldComponentClass, newComponentClass)
    if not self.enable then
        oop.error('ECS', 'Entity:ReplaceComponent->The enity has been disabled')
        return
    end

    if not oldComponentClass and not newComponentClass then
        oop.error('ECS', 'Entity:ReplaceComponent->The component is nil')
        return
    end

    self.cachedComponents = nil

    if oldComponentClass and not newComponentClass then
        self:RemoveComponent(oldComponentClass)
    elseif oldComponentClass and newComponentClass then
        local oldComponent = self:removeComponentClass(oldComponentClass)
        local newComponent = self:addComponentClass(newComponentClass)
        self.onComponentReplacedEvent:Invoke(self, oldComponent, newComponent)
        self:releaseComponent(oldComponent)
    elseif not oldComponentClass and newComponentClass then
        self:AddComponent(newComponentClass)
    end
end

function Entity:ModifyComponent(componentClass, modifyDelegate, modifyTag)
    if not self.enable then
        oop.error('ECS', 'Entity:ModifyComponent->The enity has been disabled')
        return
    end

    local component = self:GetComponent(componentClass)
    if not component then
        modifyDelegate:ActionInvoke(self, component)
        self.onComponentModifiedEvent:Invoke(self, component, modifyTag)
    else
        oop.error('ECS', 'Entity:ModifyComponent->The component is not found')
    end
end

function Entity:MarkComponentModified(component, modifyTag)
    if not self.enable then
        oop.error('ECS', 'Entity:ModifyComponent->The enity has been disabled')
        return
    end
    if component then
        self.onComponentModifiedEvent:Invoke(self, component, modifyTag)
    end
end

function Entity:releaseComponent(component)
    local componentClass = component:GetBaseClass()
    local unpooledIndex = tindexof(self.unpooledComponentClasses, componentClass)
    if unpooledIndex < 0 then
        tremove(self.unpooledComponentClasses, unpooledIndex)
    else
        self.context:releaseComponent(component)
    end
end

function Entity:OnGet()
    self.enable = true
end

function Entity:OnRelease()
    self.enable = false
    self.uid = -1
    self.context = nil
    self.cachedComponents = nil

    self.onComponentAddedEvent:Clear()
    self.onComponentRemovedEvent:Clear()
    self.onComponentReplacedEvent:Clear()
    self.onComponentModifiedEvent:Clear()

    tclear(self.unpooledComponentClasses)

    local values = tvalues(self.componentDic)
    tclear(self.componentDic)
    for i = 1, #values, 1 do
        self:releaseComponent(values[i])
    end
end

function Entity:Destroy()
    self.context:ReleaseEntity(self)
end

return Entity
